[
  {
    "path": "posts/2020-07-06-a-first-look-at-parallel-cuhre-subregions/",
    "title": "A first look at parallel CUHRE subregions",
    "description": "A first analysis the shapes of subregions generated by the parallel CUHRE algorithm.\nWe are looking to determine whether parallel CUHRE is prone to producing very\nenlongated regions.",
    "author": [
      {
        "name": "Marc Paterno",
        "url": "https://github.com/marcpaterno"
      }
    ],
    "date": "2020-07-06",
    "categories": [],
    "contents": "\nThe integrand\nThe integrand chosen is: \\[ | \\cos(4 v +5 w + 6 x +7 y + 8 z)/k |\\] with \\(k = 0s .6371054\\). For this integrand, the normalization is approximate. The true value of the integrand is close to, but not exactly, 1.\nThe data recorded\n\n\n# Download the data if it does not already exist locally.\nif (!file.exists(\"df5.fst\")) {\n  filename <- \"genz_1abs_5d_regions.csv.xz\"\n  downloadstatus <- \n    download.file(sprintf(\"https://zenodo.org/record/4319038/files/%s\", filename),\n                  filename)\n  stopifnot(downloadstatus == 0)\n  tmp <- readr::read_csv(filename)\n  unlink(filename)\n  tmp <- as_tibble(tmp)\n  fst::write_fst(tmp, \"df5.fst\")\n  rm(tmp)\n}\n\n\n\n\n\ndf5 <- fst::read_fst(\"df5.fst\") %>%\n  mutate(vol = dim0 * dim1 * dim2 * dim3 * dim4)\n\n\n\n\n\nsummary(df5)\n\n\n     value               error                dim0         \n Min.   :0.000e+00   Min.   :0.000e+00   Min.   :0.003906  \n 1st Qu.:4.000e-11   1st Qu.:1.641e-12   1st Qu.:0.015625  \n Median :2.100e-10   Median :1.219e-11   Median :0.031250  \n Mean   :1.653e-08   Mean   :2.799e-11   Mean   :0.024985  \n 3rd Qu.:8.100e-10   3rd Qu.:4.131e-11   3rd Qu.:0.031250  \n Max.   :4.227e-05   Max.   :8.140e-10   Max.   :0.125000  \n      dim1               dim2               dim3         \n Min.   :0.003906   Min.   :0.003906   Min.   :0.003906  \n 1st Qu.:0.015625   1st Qu.:0.015625   1st Qu.:0.015625  \n Median :0.015625   Median :0.015625   Median :0.015625  \n Mean   :0.021813   Mean   :0.017782   Mean   :0.015785  \n 3rd Qu.:0.031250   3rd Qu.:0.015625   3rd Qu.:0.015625  \n Max.   :0.125000   Max.   :0.125000   Max.   :0.125000  \n      dim4               div            vol           \n Min.   :0.003906   Min.   : 0.0   Min.   :2.000e-12  \n 1st Qu.:0.007812   1st Qu.:13.0   1st Qu.:4.660e-10  \n Median :0.015625   Median :14.0   Median :1.863e-09  \n Mean   :0.014392   Mean   :14.5   Mean   :1.654e-08  \n 3rd Qu.:0.015625   3rd Qu.:16.0   3rd Qu.:3.725e-09  \n Max.   :0.125000   Max.   :24.0   Max.   :3.052e-05  \n\nVariations with div\ndiv is the number of divisions this volume has been subject to (since the start of Phase 2).\nFor this integrand, the estimated value of the integral over the subregion decreases with the number of divisions:\n\n\nggplot(df5, aes(div, value, group = div)) +\n  geom_boxplot() +\n  scale_y_log10() +\n  labs(x=\"Number of divisions for the volume\", y=\"value of integral in volume\")\n\n\n\n\nHow “stretched” are the subregions?\nWe define the quantity stretch to be the ratio of the maximum subregion extent to the minimum subregion extent. A hypercube would have a stretch of 1.\n\n\ndf5 <- mutate(df5, mind = pmin(dim0, dim1, dim2, dim3, dim4),\n            maxd = pmax(dim0, dim1, dim2, dim3, dim4),\n            stretch = maxd/mind)\n\n\n\n\n\nggplot(df5, aes(stretch)) +\n  geom_histogram(bins = 50, binwidth = 1, center = 0)\n\n\n\n\nNo region from this application of the algorithm has a stretch of more than 4. At least for this integrand, there is no sign that the algorithm is making very enlongated regions.\n\n\n\n",
    "preview": "posts/2020-07-06-a-first-look-at-parallel-cuhre-subregions/a-first-look-at-parallel-cuhre-subregions_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2020-12-12T13:31:26-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-10-where-serial-cuhre-evaluates-functions/",
    "title": "Where serial CUHRE evaluates functions",
    "description": "A visualization of where CUHRE evaluates functions for a 2-dimensional integrand.",
    "author": [
      {
        "name": "Marc Paterno",
        "url": "https://github.com/marcpaterno"
      }
    ],
    "date": "2020-06-10",
    "categories": [],
    "contents": "\nThis document shows where the serial CUHRE algorithm evaluates the function it is integrating. Unlike a Monte Carlo algorithm (such as VEGAS), CUHRE evaluates the function at a set of deterministically chosen points.\nThe function used as the integrand in this example is:\n\\[ 2 x^2 + 2 y - y^2.\\] We have used both VEGAS and CUHRE to integrate this function, using a fractional error tolerance of 0.01. The large fractional error was chosen to limit the number of function evaluations. This function is sufficiently simple that CUHRE uses only two regions. The plots show where VEGAS and CUHRE each evaluate the function to achieve this level of accuracy.\n\n\n\nVEGAS required 2500 function evaluations, and CUHRE required 195.\n\n\n\n\n\n\n",
    "preview": "posts/2020-06-10-where-serial-cuhre-evaluates-functions/where-serial-cuhre-evaluates-functions_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2020-12-11T15:26:19-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-08-the-genz-function-1-in-8d/",
    "title": "The Genz function 1 in 8d",
    "description": "This document shows a performance comparison between the serial\nand parallel implementations of the CUHRE algorithm for a\nnon-positive-definite integrand.",
    "author": [
      {
        "name": "Marc Paterno",
        "url": "https://github.com/marcpaterno"
      }
    ],
    "date": "2020-06-08",
    "categories": [],
    "contents": "\nThe integrand\nThe integrand chosen is: \\[ \\cos(s + 2 t + 3 u +4 w +5 w + 6 x +7 y + 8 z) / k\\] with \\[ k = (1/315)  \\sin(1)  \\sin(3/2) \\sin(2) \\sin(5/2) \\sin(3) \n       \\sin(7/2) \\sin(4) (\\sin(37/2) - \\sin(35/2)). \\]\n\\(k\\) is approximately equal to 3.43955795218325e-05.\nTesting environment\nThese tests were run on ibmpower9.fnal.gov.\nThe Power9 machine used in these tests is a PowerNV 8335-GTG (AC 922) system. It has two processors, each with 8 cores. Each core has 4 slices.\n\nDescription of the dataframe\nalg: the name of the algorithm\nepsrel: the fractional error target\nvalue: the estimated value of the integral\nerrorest: the estimated error for the result\nerror: the absolute difference between the estimated value and the true value\nneval: the number of function evaluations used\nnregions: the number of regions used\ntime: the time in milliseconds for the calculation\nr: ratio of (errorest/(epsrel*value)); this should be less than 1 if the algorithm has converged\nconverged: boolean showing whether r < 1\nA value of NA indicates that the algorithm did not converge, but rather stopped because the maximum number of function evaluations had been reached.\n\n\nalg\nepsrel\nvalue\nerrorest\nerror\nneval\nnregions\ntime\nr\ncuhre\n1.00e-03\n0.9999127\n0.0009999\n8.73e-05\n48526075\n21958\n26820.71\n0.9999513\ncuhre\n5.00e-04\n1.0000750\n0.0005000\n7.51e-05\n79205295\n35840\n44249.74\n0.9999650\ncuhre\n2.50e-04\n1.0000490\n0.0002500\n4.89e-05\n124311395\n56250\n70582.94\n0.9999806\ncuhre\n1.25e-04\n1.0000140\n0.0001250\n1.36e-05\n202753135\n91744\n121709.60\n0.9999916\ncuhre\n6.25e-05\n1.0000040\n0.0000625\n4.10e-06\n335613915\n151862\n230264.20\n0.9999955\ncuhre\n3.12e-05\n1.0000010\n0.0000312\n1.50e-06\n548874495\n248360\n451179.80\n0.9999961\ncuhre\n1.56e-05\n0.9999997\n0.0000156\n3.00e-07\n882520405\n399331\n935296.90\n0.9999971\ncuhre\n7.80e-06\n1.0000010\n0.0000078\n9.00e-07\n1388581675\n628318\n2060807.00\n0.9999987\ncuhre\n3.90e-06\n1.0000000\n0.0000039\n2.00e-07\n2117439675\n958118\n4446506.00\n0.9999990\ncuhre\n2.00e-06\n1.0000000\n0.0000020\n2.00e-07\n3294176275\n1490578\n10027550.00\n0.9999995\n\nAnalysis\nWe do not yet have results from the parallel algorithm. These results are from the serial algorithm.\nBecause the range of fractional error tolerance values is large, and the range of times is very large, we use log scales for our plot. The line is a fitted linear model; the fit is clearly poor.\n\n\n\nThe number of regions needed to obtain a given fractional error tolerance seems to be related in a power law to the reciprocal of the fractional error tolerance.\n\n\n\n\n\n\n",
    "preview": "posts/2020-06-08-the-genz-function-1-in-8d/the-genz-function-1-in-8d_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2020-12-11T15:30:34-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-06-welcome-to-the-blog/",
    "title": "Welcome to the blog",
    "description": "Welcome to our new blog, GPU Integration Notes.",
    "author": [
      {
        "name": "Marc Paterno",
        "url": "https://github.com/marcpaterno"
      }
    ],
    "date": "2020-06-06",
    "categories": [],
    "contents": "\nThis will be the place where we post articles describing the work on our laboratory-directed research and development project “Numerical Integration on GPUs” (LDRD-2020-050). This project is supported by the Fermi National Accelerator Laboratory’s LDRD program.\nThe research is being conducted by:\nDr. Marc Paterno (Fermi National Accelerator Laboratory)\nIoannis Sakiotis (Old Dominion University)\nProf. Desh Ranjan (Old Dominion University)\nProf. Balsa Terzoc (Old Dominion University)\nProf. Mohammad Zubair (Old Dominion University)\n\n\n\n",
    "preview": {},
    "last_modified": "2020-12-10T11:54:37-06:00",
    "input_file": {}
  }
]
